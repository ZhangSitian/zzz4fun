# 数据库设计规范

- [命名规范](#命名规范)
- [基本设计规范](#基本设计规范)
- [索引设计规范](#索引设计规范)
- [字段设计规范](#字段设计规范)
- [SQL开发规范](#SQL开发规范)
- [操作行为规范(运维)](#操作行为规范(运维))

## 命名规范

- 所有数据库对象名称是`小写字母并用下划线`分割（Linux OS 区分大小写）
- 所有数据库对象名称禁止使用 [MySQL保留关键字](https://www.cnblogs.com/zhuyeshen/p/11496545.html)
- 所有数据库对象名称必须要`见名识义`，并且最好不超过32个字符
- 临时表：以 `tmp` 为前缀并以日期为后缀
- 备份表：以 `bak` 为前缀并以日期为后缀
- 所有存储`相同数据的列名和列类型必须一致`（不同列名影响性能）


- lym_userdb(零壹码网的用户数据库)
- user_account(用户账号表)

## 基本设计规范

- MySQL 5.5 使用之前 MyISAM(默认存储引擎)

- 所有表必须使用 `InnoDB` 存储引擎
  - 5.6 + 默认引擎
  - 支持事务，行级锁，更好恢复性，高并发下性能更好
- 数据库表和字符集统一使用 `UTF8`
  - 避免字符集转换乱码
  - `UTF—8 字符集汉字占用3个字节`
- 所有表和字段必须添加注释
  - 便于以后数据字典的维护
- 尽量控制单表数据量大小，建议控制在`500万以内`
  - 500万并不是 MySQL 数据库限制
  - 存储多少万数据？取决于存储设置和文件系统
  - 历史数据归档、分库分表(业务)等手段来控制数据量大小
- 谨慎使用 MySQL分区表
  - 分区表在物理上表现为多个文件，在逻辑上表现为一个表
  - 分区键，跨分区查询效率可能更低
  - 建议才用物理分表的方式管理大数据

- 冷热数据分离，减少表的字段
  - MySQL 限制做多存储 4096列
  - MySQL 每行不能超过 65535字节
  - 减少磁盘 IO，保证热数据缓存命中率
  - 利用更有效的利用缓存，避免读取无用的冷数据
  - 经常一起使用的列放在一起

- 禁止在表中预留字段
  - 见名识义
  - 预留字段无法确认存储的数据类型，所有无法选择合适的类型
  - 对预留字段类型的修改，会对表进行锁定
- 禁止存储图片/文件等二进制数据
- 禁止在线上做数据库压力测试（可以在开发环境测试）
- 禁止从开发环境，测试环境直连生产环境

## 索引设计规范

> 对查询性能非常重要

- 不要滥用索引
- 限制每张表的索引数量，建议单表索引不超过5个
  - 与列数量成正比
  - 索引提高效率同时可以降低效率
- `InnoDB` 表必须有一个主键
  - 不适用更新频繁的列作为主键，不使用多列主键
  - 不使用 uuid,md5,hash,字符串列作为主键
- 使用自增 ID 值

- 常见索引列建议：
  - select,update,delete 语句的 where 从句中的列
  - 包含在 order by, group by, distinct 中的字段
  - 多表 join 的关联列

- 如何选择索引列的顺序
  - 从左到右的顺序来使用
    - 区分度最高的列放在联合索引的最左侧
    - 尽量字段长度小的列放在联合索引的最左侧
    - 使用最频繁的列放到联合做引的左侧
- 避免建立冗余索引和重复索引
  - index(a,b,c), index(a,b), index(a)

- 频繁查询有限考虑使用覆盖索引
  - 覆盖索引：包含了素有查询字段的索引(where,order by, group by)
  - 好处：
    - 避免innodb表进行索引的二次查找
    - 随机IO变为顺序IO加快查询效率

- 尽量避免使用外键
  - 不建议使用外键约束
  - 在业务端实现
  - 外键影响父表和子表的写操作从而降低性能

## 字段设计规范

- 优先选择符合存储需要的**最小的数据类型**
  - inet_aton('255.255.255.255') = 4294967295
  - inet_ntoa(4294967295) = '255.255.255.255'

4 byte vs 15 byte

- 选择非负整型数据选择无符号整型数据进行存储unsigned 类型
- varchar(n) n代表**字符数**，而不是字节数
  - utf8汉字varchar(255) = 占用765 byte

- 过大的长度会消耗更多的内存

- 避免使用text(max 64k), blob数据类型
  - tinytext
  - text
  - midumtext
  - longtext
  - 内存不支持text,blog 排序
  - 需要二次查询
  - 建议单独放到的扩展表中
  - text/blog只能有前缀索引，没有默认值

- 避免使用enum数据类型
  - 65535 中
  - 字符串类型
  - 修改enum值需要使用alter语句
  - enum类型的order by 操作率低，需要额外的操作
  - 禁止使用数值作为enum的枚举类型

- 尽可能吧所有列定义为NOT NULL
  - 索引null列需要额外的空间来保存，所以要占用更多的空间
  - 进行比较和计算时要对null值做特别的处理

- 使用timestamp(4 byte)或datetime(8 byte)类型存储时间
  - timestamp 1970-01-01 00:00:01 ~ 2038-03-03 03:14:07
  - timestamp 占用 4 byte 和 int 相同，但比 int 可读性高

- 超出时间范围使用 `datetime`

- 财务数据必须使用 decimal
  - 精准浮点数，在计算时不会丢失精度
  - 占用空间由定义的宽度决定
    - 每4字节存储9位数据
  - 存储比 bigint 更多的数据

## SQL开发规范

- **预编译语句**进行数据库操作

```mysql 
> prepare stmt1
> from 'select SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';
> set @a=3;
> set @b=4;
> execute stmt1 USING @a, @b;
> deallocate prepare stmt1;
```

- 只传参数，比传递SQL语句更高效
- 相同语句可以一次解析，多次使用，提高处理效率

- 避免数据类型的隐式转换
  - 隐式转换导致索引失效
  - where id='1'

- 利用表上的已经存在的索引
  - 避免使用双%好的查询条件：'%123%'
  - 一个SQL只能利用到复合索引中的一列进行范围查询
  - 使用 left join 和 not exists 来优化 not in 操作

- 不同的数据库使用不同的账号，禁止跨库查询
  - 为数据库迁移和分库分表留出余地
  - 降低业务耦合度
  - 避免权限过大而产生的安全风险
- 禁止使用select*
  - 消耗更多的CPU和IO以及网络带宽资源
  - 无法使用覆盖索引
  - 可以减少表结构变更带来的影响

- 禁止是不含字段列表的insert 语句
  - insert int t value('a','b')
  - insert into t(c1,c2) values('a','b')
  - 可以减少结构变更带来的影响

- 禁止子查询，子查询优化位join操作
  - 在查询结果集无法使用索引
  - 产生临时表操作，如果子查询数据量大则严重影响效率
  - 消耗过多的CPU和IO资源

- 避免使用join关联太多的表
  - 每join一个表会多占用一部分内存(join_buffer_size)
  - 会产生临时表操作，应影响查询效率
  - MySQL 最多允许关联61个表，建议不超过5个

- 减少同数据库的交互次数
  - 分页显示：不要提取 第一页结果
  - 数据库更合适处理批量操作
  - 合并多个相同的操作到一起，可以提高处理效果
  - alter table t1 add column c1int, add. ...

- 使用 in 代替 or
  - in 的值不要超过 500个
  - in 操作可以有效的利用索引

- 禁止使用 order by rand() 进行随机排序
  - 会把所有符合条件的数据装载到内存中进行排序
  - 消耗大量的CPU和IO及内存资源
  - 在程序中获取一个随机值，然后从数据库中获取数据

- where 从句中禁止对列进行函数转换和计算
  - 导致无法使用索引
  - where date(createtime) = '20160901'
  - where createtime >= '20160901' and createtime < '20161010'

- 不会有重复值的使用union all ，而不是union
  - union 把所有数据放到临时表中后再进行去重操作
  - union all 不会再对结果集进行去重操作

- 拆分复杂的大 SQL 为多个小 SQL
  - MySQL 一个 SQL 只能使用一个CPU进行计算
  - 通过并行执行来提高处理效率

## 操作行为规范(运维)

- 超 100万行的批量写操作，要分批多次进行操作
  - 大批量操作可能造成严重的主从延迟
  - binlog 日志为row格式时会产生大量的日志
  - 避免产生大事务操作

- 对大表数据结构修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的。 10分钟表锁，会出现在线延迟

- 对大表使用pt-online-schema-change修改表结构
  - percona开发的工具
  - (1) 新建表与原来表一样，并修改表结构
  - (2) 复制数据到新表中，并在源表中增加触发器，把新增的数据也增加在新表中。在行的数据完成之后，在源表上加上事件锁

  - 避免大表修改产生的主从延迟
  - 避免在对表字段进行修改时进行锁表

- 禁止为程序程序使用的账号赋予super权限
  - 当达到最大连接数限制时，还允许1个有super权限的用户连接
  - super权限只能留给DBA 处理问题的账号使用

- 程序连接数据库账号，遵循权限最小原则
  - 不准夸库
  - 程序使用账号原则上不准有drop权限
